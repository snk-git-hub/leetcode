Recursion Patterns with LeetCode Problems
1. Take / Not Take Pattern
Problems:
LeetCode 78 - Subsets
LeetCode 416 - Partition Equal Subset Sum
LeetCode 494 - Target Sum
LeetCode 698 - Partition to K Equal Sum Subsets
// LeetCode 78: Subsets
class Solution {
public:
    void solve(vector<int>& nums, int idx, vector<int>& current, 
               vector<vector<int>>& result) {
        if (idx == nums.size()) {
            result.push_back(current);
            return;
        }
        
        // Take
        current.push_back(nums[idx]);
        solve(nums, idx + 1, current, result);
        current.pop_back();
        
        // Not Take
        solve(nums, idx + 1, current, result);
    }
    
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> current;
        solve(nums, 0, current, result);
        return result;
    }
};
2. Try All Choices Pattern
Problems:
LeetCode 22 - Generate Parentheses
LeetCode 17 - Letter Combinations of a Phone Number
LeetCode 39 - Combination Sum
LeetCode 46 - Permutations
// LeetCode 22: Generate Parentheses
class Solution {
public:
    void generate(int open, int close, int n, string current, 
                  vector<string>& result) {
        if (current.length() == 2 * n) {
            result.push_back(current);
            return;
        }
        
        if (open < n) {
            generate(open + 1, close, n, current + '(', result);
        }
        if (close < open) {
            generate(open, close + 1, n, current + ')', result);
        }
    }
    
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        generate(0, 0, n, "", result);
        return result;
    }
};
// LeetCode 17: Letter Combinations of Phone Number
class Solution {
public:
    vector<string> mapping = {"", "", "abc", "def", "ghi", "jkl", 
                              "mno", "pqrs", "tuv", "wxyz"};
    
    void solve(string& digits, int idx, string current, 
               vector<string>& result) {
        if (idx == digits.size()) {
            result.push_back(current);
            return;
        }
        
        string letters = mapping[digits[idx] - '0'];
        for (char c : letters) {
            solve(digits, idx + 1, current + c, result);
        }
    }
    
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector<string> result;
        solve(digits, 0, "", result);
        return result;
    }
};
3. Include-Exclude with Loop Pattern
Problems:
LeetCode 90 - Subsets II (with duplicates)
LeetCode 40 - Combination Sum II
LeetCode 47 - Permutations II
// LeetCode 90: Subsets II (with duplicates)
class Solution {
public:
    void solve(vector<int>& nums, int idx, vector<int>& current,
               vector<vector<int>>& result) {
        result.push_back(current);
        
        for (int i = idx; i < nums.size(); i++) {
            if (i > idx && nums[i] == nums[i-1]) continue; // skip duplicates
            
            current.push_back(nums[i]);
            solve(nums, i + 1, current, result);
            current.pop_back();
        }
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        vector<int> current;
        solve(nums, 0, current, result);
        return result;
    }
};
4. Up-Down-Left-Right (Grid) Pattern
Problems:
LeetCode 200 - Number of Islands
LeetCode 79 - Word Search
LeetCode 130 - Surrounded Regions
LeetCode 733 - Flood Fill
// LeetCode 200: Number of Islands
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        if (i < 0 || i >= grid.size() || j < 0 || 
            j >= grid[0].size() || grid[i][j] == '0') {
            return;
        }
        
        grid[i][j] = '0'; // mark visited
        
        dfs(grid, i + 1, j); // down
        dfs(grid, i - 1, j); // up
        dfs(grid, i, j + 1); // right
        dfs(grid, i, j - 1); // left
    }
    
    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
};
// LeetCode 79: Word Search
class Solution {
public:
    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int idx) {
        if (idx == word.size()) return true;
        
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() 
            || board[i][j] != word[idx]) {
            return false;
        }
        
        char temp = board[i][j];
        board[i][j] = '#'; // mark visited
        
        bool found = dfs(board, word, i+1, j, idx+1) ||
                     dfs(board, word, i-1, j, idx+1) ||
                     dfs(board, word, i, j+1, idx+1) ||
                     dfs(board, word, i, j-1, idx+1);
        
        board[i][j] = temp; // backtrack
        return found;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (dfs(board, word, i, j, 0)) return true;
            }
        }
        return false;
    }
};
5. Partition Pattern
Problems:
LeetCode 131 - Palindrome Partitioning
LeetCode 93 - Restore IP Addresses
// LeetCode 131: Palindrome Partitioning
class Solution {
public:
    bool isPalindrome(string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }
    
    void solve(string& s, int start, vector<string>& current,
               vector<vector<string>>& result) {
        if (start == s.size()) {
            result.push_back(current);
            return;
        }
        
        for (int end = start; end < s.size(); end++) {
            if (isPalindrome(s, start, end)) {
                current.push_back(s.substr(start, end - start + 1));
                solve(s, end + 1, current, result);
                current.pop_back();
            }
        }
    }
    
    vector<vector<string>> partition(string s) {
        vector<vector<string>> result;
        vector<string> current;
        solve(s, 0, current, result);
        return result;
    }
};
6. Tree Recursion (DFS)
Problems:
LeetCode 104 - Maximum Depth of Binary Tree
LeetCode 226 - Invert Binary Tree
LeetCode 112 - Path Sum
LeetCode 437 - Path Sum III
LeetCode 124 - Binary Tree Maximum Path Sum
// LeetCode 104: Maximum Depth
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
// LeetCode 112: Path Sum
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;
        
        if (!root->left && !root->right) {
            return targetSum == root->val;
        }
        
        return hasPathSum(root->left, targetSum - root->val) ||
               hasPathSum(root->right, targetSum - root->val);
    }
};
7. Match/Skip Pattern
Problems:
LeetCode 10 - Regular Expression Matching
LeetCode 44 - Wildcard Matching
LeetCode 72 - Edit Distance
// LeetCode 44: Wildcard Matching
class Solution {
public:
    bool isMatch(string s, string p, int i, int j, vector<vector<int>>& dp) {
        if (j == p.size()) return i == s.size();
        
        if (dp[i][j] != -1) return dp[i][j];
        
        if (p[j] == '*') {
            // Skip * or match one character
            bool result = isMatch(s, p, i, j + 1, dp) || 
                         (i < s.size() && isMatch(s, p, i + 1, j, dp));
            return dp[i][j] = result;
        }
        
        bool firstMatch = i < s.size() && (s[i] == p[j] || p[j] == '?');
        bool result = firstMatch && isMatch(s, p, i + 1, j + 1, dp);
        return dp[i][j] = result;
    }
    
    bool isMatch(string s, string p) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, -1));
        return isMatch(s, p, 0, 0, dp);
    }
};
8. N-Queens / Backtracking Pattern
Problems:
LeetCode 51 - N-Queens
LeetCode 52 - N-Queens II
LeetCode 37 - Sudoku Solver
// LeetCode 51: N-Queens
class Solution {
public:
    bool isSafe(vector<string>& board, int row, int col, int n) {
        // Check column
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // Check upper left diagonal
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // Check upper right diagonal
        for (int i = row, j = col; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    }
    
    void solve(int row, int n, vector<string>& board,
               vector<vector<string>>& result) {
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isSafe(board, row, col, n)) {
                board[row][col] = 'Q';
                solve(row + 1, n, board, result);
                board[row][col] = '.';
            }
        }
    }
    
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> result;
        vector<string> board(n, string(n, '.'));
        solve(0, n, board, result);
        return result;
    }
};
9. Memoization Pattern
Problems:
LeetCode 70 - Climbing Stairs
LeetCode 509 - Fibonacci Number
LeetCode 322 - Coin Change
LeetCode 139 - Word Break
// LeetCode 70: Climbing Stairs
class Solution {
public:
    int climbStairs(int n, vector<int>& dp) {
        if (n <= 2) return n;
        if (dp[n] != -1) return dp[n];
        
        return dp[n] = climbStairs(n-1, dp) + climbStairs(n-2, dp);
    }
    
    int climbStairs(int n) {
        vector<int> dp(n + 1, -1);
        return climbStairs(n, dp);
    }
};
10. Divide and Conquer Pattern
Problems:
LeetCode 23 - Merge k Sorted Lists
LeetCode 215 - Kth Largest Element
LeetCode 108 - Convert Sorted Array to BST
// LeetCode 108: Convert Sorted Array to BST
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;
        
        int mid = left + (right - left) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        
        root->left = sortedArrayToBST(nums, left, mid - 1);
        root->right = sortedArrayToBST(nums, mid + 1, right);
        
        return root;
    }
    
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return sortedArrayToBST(nums, 0, nums.size() - 1);
    }
};
These are the most common recursion patterns you'll encounter on LeetCode. Practice these and you'll be able to recognize and solve most recursion problems!
